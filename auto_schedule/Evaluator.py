import os
import tvm
import numpy as np
from decorator import decorate
from tvm import autotvm
from tvm.autotvm import util
from .Actions import *


class BaseEvaluator(object):
    pass


class SimpleEvaluator(BaseEvaluator):
    def __init__(self):
        super(SimpleEvaluator, self).__init__()

    def evaluate(self, s, arg_bufs, target, dev_id=0, number=1, record_mode=False):
        func = tvm.build(s, arg_bufs)
        ctx = tvm.context(target, dev_id)
        tvm_arys = []
        for arg in arg_bufs:
            shape = util.get_const_tuple(arg.shape)
            tmp = np.random.uniform(-10, 10, size=shape).astype(arg.dtype)
            tmp = tvm.nd.array(tmp, ctx)
            tvm_arys.append(tmp)
        evaluator = func.time_evaluator(func.entry_name, ctx, number=number)
        time_cost = evaluator(*tvm_arys).mean * 1e3
        if record_mode:
            lower_string = str(tvm.lower(s, arg_bufs, simple_mode=True))
            return time_cost, lower_string
        return time_cost


# class TVMEvaluator(object):
#     """
#     Autotvm layer for parameter tuning
#     """
#     def __init__(self, compute, args, ops, bufs):
#         """
#         :param compute:  function
#             a callable object returns list of Operation and list of tvm.Tensor
#         :param args:  list | tuple
#             arguments for compute
#         :param ops:  list of operation
#         :param bufs:  list of tvm.Tensor
#         """
#         self._compute = compute
#         self._args = args
#         self._ops = ops
#         self._bufs = bufs
#         self._schedule_template = []
#         self._lower_string = ""
#
#     def get_compute_name(self):
#         return self._compute.__name__
#
#     def get_template(self):
#         """
#         Print the schedule templates
#         :return:  None
#         """
#         res = ""
#         for s in self._schedule_template:
#             res += s
#             res += '\n'
#         return res
#
#     def get_lower(self):
#         """
#         Print the final lowered function
#         :return:  None
#         """
#         return self._lower_string
#
#     def generate(self, track, env, record_mode=False):
#         """
#         Generate schedule template
#
#         :param track:  list of Operation
#         :param env:  Env
#         :param record_mode: bool
#         :return: tvm.Schedule, list of tvm.Tensor
#         """
#         def call(f, *args, **kwargs):
#             self._schedule_template.clear()
#             s = tvm.create_schedule(self._ops)
#             cfg = autotvm.get_config()
#             op2record = dict()
#             for op in track:
#                 node = env.op2node[op]
#                 # Here reset to get real axes
#                 record = Record(node)
#                 op2record[op] = record
#                 for sch in node.get_schedule_list():
#                     if isinstance(sch, Split):
#                         sch.template_apply(s, record, cfg, record_mode, self._schedule_template)
#                     elif isinstance(sch, Reorder):
#                         sch.template_apply(s, record, cfg, record_mode, self._schedule_template)
#                     else:
#                         raise NotImplementedError("Not support schedule primitive {}".format(sch.__class__.__name__))
#             return s, self._bufs
#
#         result = decorate(self._compute, call)
#         result.__name__ = self._compute.__name__
#         result = autotvm.template(result)
#         return result
#
#     def tvm_run(self, template, target, dev_id=0, n_trial=20, number=3, record_mode=False, merge_log=True):
#         """
#         Use autotvm tune to get real schedule
#
#         :param template: callable
#             schedule template
#         :param target:  str
#             device name, e.g. "llvm"
#         :param dev_id:  int
#             device number, e.g. 0
#         :param n_trial:  int
#             how many trial points to search
#         :param number:  int
#             for a certain point, how many times to run it
#         :param record_mode:  bool
#         :param merge_log: bool
#             whether to merge log files
#         :return: float, callable
#             time cost and the final function generated by tvm.build
#         """
#         outfile = template.func_name + "_" + str(os.getpid()) + '.log'
#         if os.path.exists(outfile):
#             if merge_log:
#                 with open(outfile + ".merge", "a") as fout:
#                     with open(outfile, "r") as fin:
#                         for line in fin:
#                             fout.write(line)
#             os.remove(outfile)
#         task = autotvm.task.create(template, args=self._args, target=target)
#         measure_option = autotvm.measure_option(builder="local", runner=autotvm.LocalRunner(number=5, timeout=100))
#         tuner = autotvm.tuner.XGBTuner(task)
#         tuner.tune(n_trial=n_trial, measure_option=measure_option,
#                    callbacks=[autotvm.callback.log_to_file(outfile)])
#
#         with autotvm.apply_history_best(outfile):
#             with tvm.target.create(target):
#                 s, arg_bufs = template(*self._args)
#                 if record_mode:
#                     self._lower_string = str(tvm.lower(s, arg_bufs, simple_mode=True))
#                 func = tvm.build(s, arg_bufs)
#         ctx = tvm.context(target, dev_id)
#         tvm_arys = []
#         for arg in arg_bufs:
#             shape = util.get_const_tuple(arg.shape)
#             tmp = np.random.uniform(-10, 10, size=shape).astype(arg.dtype)
#             tmp = tvm.nd.array(tmp, ctx)
#             tvm_arys.append(tmp)
#         evaluator = func.time_evaluator(func.entry_name, ctx, number=number)
#         time_cost = evaluator(*tvm_arys).mean
#         return time_cost, func
#
#     def evaluate(self, track, env, target, dev_id=0, n_trial=20, number=3, record_mode=False):
#         """
#         Use this to evaluate current schedule template
#
#         :param track:  list of Operation
#         :param env:  Env
#         :param target:  str
#         :param dev_id:  int
#         :param n_trial:  int
#         :param number:  int
#         :param record_mode: bool
#         :return: tuple(float, function)
#         """
#         template = self.generate(track, env, record_mode)
#         result = self.tvm_run(template, target, dev_id, n_trial, number, record_mode)
#         return result